
start.o:     file format elf32-littlearm


Disassembly of section .text:

00000000 <reset>:
	.global	switch_to_hypervisor_ret
#endif

reset:
	/* Allow the board to save important registers */
	b	save_boot_params
   0:	eafffffe 	b	64 <save_boot_params>

00000004 <save_boot_params_ret>:

#ifdef CONFIG_ARMV7_LPAE
/*
 * check for Hypervisor support
 */
	mrc	p15, 0, r0, c0, c1, 1		@ read ID_PFR1
   4:	ee100f31 	mrc	15, 0, r0, cr0, cr1, {1}
	and	r0, r0, #CPUID_ARM_VIRT_MASK	@ mask virtualization bits
   8:	e2000a0f 	and	r0, r0, #61440	; 0xf000
	cmp	r0, #(1 << CPUID_ARM_VIRT_SHIFT)
   c:	e3500a01 	cmp	r0, #4096	; 0x1000
	beq	switch_to_hypervisor
  10:	0afffffe 	beq	68 <switch_to_hypervisor>

00000014 <switch_to_hypervisor_ret>:
#endif
	/*
	 * disable interrupts (FIQ and IRQ), also set the cpu to SVC32 mode,
	 * except if in HYP mode already
	 */
	mrs	r0, cpsr
  14:	e10f0000 	mrs	r0, CPSR
	and	r1, r0, #0x1f		@ mask mode bits
  18:	e200101f 	and	r1, r0, #31
	teq	r1, #0x1a		@ test for HYP mode
  1c:	e331001a 	teq	r1, #26
	bicne	r0, r0, #0x1f		@ clear all mode bits
  20:	13c0001f 	bicne	r0, r0, #31
	orrne	r0, r0, #0x13		@ set SVC mode
  24:	13800013 	orrne	r0, r0, #19
	orr	r0, r0, #0xc0		@ disable FIQ and IRQ
  28:	e38000c0 	orr	r0, r0, #192	; 0xc0
	msr	cpsr,r0
  2c:	e129f000 	msr	CPSR_fc, r0
#if !CONFIG_IS_ENABLED(SYS_NO_VECTOR_TABLE)
/*
 * Setup vector:
 */
	/* Set V=0 in CP15 SCTLR register - for VBAR to point to vector */
	mrc	p15, 0, r0, c1, c0, 0	@ Read CP15 SCTLR Register
  30:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
	bic	r0, #CR_V		@ V = 0
  34:	e3c00a02 	bic	r0, r0, #8192	; 0x2000
	mcr	p15, 0, r0, c1, c0, 0	@ Write CP15 SCTLR Register
  38:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}

#ifdef CONFIG_HAS_VBAR
	/* Set vector address in CP15 VBAR register */
	ldr	r0, =_start
  3c:	e59f00e0 	ldr	r0, [pc, #224]	; 124 <boot_now+0x4>
	mcr	p15, 0, r0, c12, c0, 0	@Set VBAR
  40:	ee0c0f10 	mcr	15, 0, r0, cr12, cr0, {0}
#endif

	/* the mask ROM code should have PLL and others stable */
#if !CONFIG_IS_ENABLED(SKIP_LOWLEVEL_INIT)
#ifdef CONFIG_CPU_V7A
	bl	cpu_init_cp15
  44:	ebfffffe 	bl	6c <cpu_init_cp15>
#endif
#if !CONFIG_IS_ENABLED(SKIP_LOWLEVEL_INIT_ONLY)
	bl	cpu_init_crit
  48:	ebfffffe 	bl	cc <cpu_init_crit>
#endif
#endif

	bl	kcci_led_test
  4c:	ebfffffe 	bl	d0 <kcci_led_test>
	bl	_main
  50:	ebfffffe 	bl	0 <_main>

00000054 <c_runtime_cpu_setup>:
ENTRY(c_runtime_cpu_setup)
/*
 * If I-cache is enabled invalidate it
 */
#if !CONFIG_IS_ENABLED(SYS_ICACHE_OFF)
	mcr	p15, 0, r0, c7, c5, 0	@ invalidate icache
  54:	ee070f15 	mcr	15, 0, r0, cr7, cr5, {0}
	dsb
  58:	f57ff04f 	dsb	sy
	isb
  5c:	f57ff06f 	isb	sy
#endif

	bx	lr
  60:	e12fff1e 	bx	lr

00000064 <save_boot_params>:
	str	r2, [r12]
	str	r1, [r12, #4]
	str	r0, [r12, #8]
	str	r3, [r12, #12]
#endif
	b	save_boot_params_ret		@ back to my caller
  64:	eafffffe 	b	4 <save_boot_params_ret>

00000068 <switch_to_hypervisor>:
END(saved_args)
#endif

#ifdef CONFIG_ARMV7_LPAE
WEAK(switch_to_hypervisor)
	b	switch_to_hypervisor_ret
  68:	eafffffe 	b	14 <switch_to_hypervisor_ret>

0000006c <cpu_init_cp15>:
#endif

	/*
	 * Invalidate L1 I/D
	 */
	mov	r0, #0			@ set up for MCR
  6c:	e3a00000 	mov	r0, #0
	mcr	p15, 0, r0, c8, c7, 0	@ invalidate TLBs
  70:	ee080f17 	mcr	15, 0, r0, cr8, cr7, {0}
	mcr	p15, 0, r0, c7, c5, 0	@ invalidate icache
  74:	ee070f15 	mcr	15, 0, r0, cr7, cr5, {0}
	mcr	p15, 0, r0, c7, c5, 6	@ invalidate BP array
  78:	ee070fd5 	mcr	15, 0, r0, cr7, cr5, {6}
	dsb
  7c:	f57ff04f 	dsb	sy
	isb
  80:	f57ff06f 	isb	sy

	/*
	 * disable MMU stuff and caches
	 */
	mrc	p15, 0, r0, c1, c0, 0
  84:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
	bic	r0, r0, #0x00002000	@ clear bits 13 (--V-)
  88:	e3c00a02 	bic	r0, r0, #8192	; 0x2000
	bic	r0, r0, #0x00000007	@ clear bits 2:0 (-CAM)
  8c:	e3c00007 	bic	r0, r0, #7
	orr	r0, r0, #0x00000002	@ set bit 1 (--A-) Align
  90:	e3800002 	orr	r0, r0, #2
	orr	r0, r0, #0x00000800	@ set bit 11 (Z---) BTB
  94:	e3800b02 	orr	r0, r0, #2048	; 0x800
#if CONFIG_IS_ENABLED(SYS_ICACHE_OFF)
	bic	r0, r0, #0x00001000	@ clear bit 12 (I) I-cache
#else
	orr	r0, r0, #0x00001000	@ set bit 12 (I) I-cache
  98:	e3800a01 	orr	r0, r0, #4096	; 0x1000
#endif
	mcr	p15, 0, r0, c1, c0, 0
  9c:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
	mrc     p15, 0, r0, c15, c0, 1	@ read diagnostic register
	orr     r0, r0, #1 << 22	@ set bit #22
	mcr     p15, 0, r0, c15, c0, 1	@ write diagnostic register
#endif

	mov	r5, lr			@ Store my Caller
  a0:	e1a0500e 	mov	r5, lr
	mrc	p15, 0, r1, c0, c0, 0	@ r1 has Read Main ID Register (MIDR)
  a4:	ee101f10 	mrc	15, 0, r1, cr0, cr0, {0}
	mov	r3, r1, lsr #20		@ get variant field
  a8:	e1a03a21 	lsr	r3, r1, #20
	and	r3, r3, #0xf		@ r3 has CPU variant
  ac:	e203300f 	and	r3, r3, #15
	and	r4, r1, #0xf		@ r4 has CPU revision
  b0:	e201400f 	and	r4, r1, #15
	mov	r2, r3, lsl #4		@ shift variant field for combined value
  b4:	e1a02203 	lsl	r2, r3, #4
	orr	r2, r4, r2		@ r2 has combined CPU variant + revision
  b8:	e1842002 	orr	r2, r4, r2

/* Early stack for ERRATA that needs into call C code */
#if defined(CONFIG_XPL_BUILD) && defined(CONFIG_SPL_STACK)
	ldr	r0, =(CONFIG_SPL_STACK)
#else
	ldr	r0, =(SYS_INIT_SP_ADDR)
  bc:	e59f0064 	ldr	r0, [pc, #100]	; 128 <boot_now+0x8>
#endif
	bic	r0, r0, #7	/* 8-byte alignment for ABI compliance */
  c0:	e3c00007 	bic	r0, r0, #7
	mov	sp, r0
  c4:	e1a0d000 	mov	sp, r0
	mrc	p15, 0, r0, c15, c0, 1	@ read diagnostic register
	orr	r0, r0, #1 << 12	@ set bit #12
	mcr	p15, 0, r0, c15, c0, 1	@ write diagnostic register
#endif

	mov	pc, r5			@ back to my caller
  c8:	e1a0f005 	mov	pc, r5

000000cc <cpu_init_crit>:
	 * Jump to board specific initialization...
	 * The Mask ROM will have already initialized
	 * basic memory. Go here to bump up clock rate and handle
	 * wake up conditions.
	 */
	b	lowlevel_init		@ go setup pll,mux,memory
  cc:	eafffffe 	b	0 <lowlevel_init>

000000d0 <kcci_led_test>:
	.word	__rel_dyn_start - pie_fixup
_rel_dyn_end_ofs:
	.word	__rel_dyn_end - pie_fixup
#endif
ENTRY(kcci_led_test)
	ldr r0,=0xFE200000
  d0:	e59f0054 	ldr	r0, [pc, #84]	; 12c <boot_now+0xc>
	ldr r1,=0x09240000
  d4:	e59f1054 	ldr	r1, [pc, #84]	; 130 <boot_now+0x10>
	str r1,[r0,#0x00]
  d8:	e5801000 	str	r1, [r0]
	ldr r1,=0x00012249		/*GPIO 16~19 input, 10~13 output*/
  dc:	e59f1050 	ldr	r1, [pc, #80]	; 134 <boot_now+0x14>
	str r1,[r0,#0x04]
  e0:	e5801004 	str	r1, [r0, #4]

	ldr r1,=0x00000000
  e4:	e3a01000 	mov	r1, #0
	str r1,[r0,#0x08]
  e8:	e5801008 	str	r1, [r0, #8]

	ldr r1,=0x00000040
  ec:	e3a01040 	mov	r1, #64	; 0x40
	
	mov r2, #8
  f0:	e3a02008 	mov	r2, #8

000000f4 <ledloop>:
ledloop:
	#ldr r4, [r0, #0x34]
	#tst r4, #(1 << 16)
	#bne boot_now

	str r1, [r0,#0x1C]
  f4:	e580101c 	str	r1, [r0, #28]
	ldr r3,=0x400000
  f8:	e3a03501 	mov	r3, #4194304	; 0x400000

000000fc <delay>:
delay:
	ldr r4,[r0,#0x34]
  fc:	e5904034 	ldr	r4, [r0, #52]	; 0x34
	#tst r4,#(1<<16)
	ands r4,#0xff0000
 100:	e21448ff 	ands	r4, r4, #16711680	; 0xff0000
	bne boot_now
 104:	1a000005 	bne	120 <boot_now>
	subs r3,r3, #1
 108:	e2533001 	subs	r3, r3, #1
	bne delay
 10c:	1afffffa 	bne	fc <delay>
	str r1,[r0,#0x28]
 110:	e5801028 	str	r1, [r0, #40]	; 0x28
	mov r1, r1, LSL #1
 114:	e1a01081 	lsl	r1, r1, #1
	subs r2, r2, #1
 118:	e2522001 	subs	r2, r2, #1
	bne ledloop
 11c:	1afffff4 	bne	f4 <ledloop>

00000120 <boot_now>:
boot_now:
	mov pc, lr
 120:	e1a0f00e 	mov	pc, lr
	ldr	r0, =_start
 124:	00000000 	.word	0x00000000
	ldr	r0, =(SYS_INIT_SP_ADDR)
 128:	07fffee0 	.word	0x07fffee0
	ldr r0,=0xFE200000
 12c:	fe200000 	.word	0xfe200000
	ldr r1,=0x09240000
 130:	09240000 	.word	0x09240000
	ldr r1,=0x00012249		/*GPIO 16~19 input, 10~13 output*/
 134:	00012249 	.word	0x00012249
